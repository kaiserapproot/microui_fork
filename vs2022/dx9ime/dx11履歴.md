# DirectX11 microui 文字化け問題・修正履歴

## 問題の発生と原因

- microuiのUIテキストはUTF-8で格納されている。
- atlas.inlはASCII英字・記号のみの1バイトグリフを持つ。
- DirectX9版(renderer.c)はUTF-8継続バイト(0x80〜0xBF)をスキップし、ASCII以外はDEL(127)で描画するロジック。
- DirectX11版(dx11_renderer.c)は初期実装で「ASCII 32〜127以外は完全スキップ」し、UTF-8継続バイトもスキップせず、ASCII以外は描画されなかった。
- そのため、英語UIラベルも文字化けし「$EMO7INDOW」「3TYLE%DITOR」など意味不明な表示になった。

## 時系列と修正の流れ

1. **DirectX11移植初期**
    - renderer.cのロジックを十分に調査せず、dx11_draw_textで`if (*p < 32 || *p > 127) continue;`とした。
    - UTF-8の継続バイト(0x80〜0xBF)もASCII以外も全てスキップされ、英語UIも正しく表示されなかった。
    - 実装例（誤った初期コード）:

```c
void dx11_draw_text(const char* text, int x, int y, mu_Color color) {
    mu_Rect dst = { x, y, 0, 0 };
    mu_Rect src;
    for (const char* p = text; *p; p++) {
        if (*p < 32 || *p > 127) continue;
        src = atlas[ATLAS_FONT + (*p - 32)];
        dst.w = src.w;
        dst.h = src.h;
        dx11_push_quad_atlas(dst, src, color);
        dst.x += dst.w;
    }
}
```

2. **誤った修正の根拠**
    - 「UTF-8デコードが必要」「日本語対応が必要」と誤認し、複雑なUTF-8処理やフォント追加を検討。
    - renderer.cのatlas.inlモードは1バイトASCIIのみで十分なことを見落とした。
    - microuiのUIラベルは英語のみであり、UTF-8デコード不要。

3. **正しい原因究明**
    - renderer.cのforループは`if ((*p & 0xc0) == 0x80) continue;`で継続バイトをスキップ。
    - ASCII以外はDEL(127)で描画し、英語UIは正しく表示される。
    - dx11_renderer.cのforループが異なっていたことが根本原因。
    - 実装例（正しいロジック）:

```c
void r_draw_text(const char* text, mu_Vec2 pos, mu_Color color) {
    mu_Rect src;
    char* p;
    int chr;
    mu_Rect dst = { pos.x, pos.y, 0, 0 };
    for (p = (char*)text; *p; p++) {
        if ((*p & 0xc0) == 0x80) { continue; }
        chr = mu_min((unsigned char)*p, 127);
        src = atlas[ATLAS_FONT + chr];
        dst.w = src.w;
        dst.h = src.h;
        push_quad(dst, src, color);
        dst.x += dst.w;
    }
}
```

4. **最終修正**
    - dx11_draw_textのforループを`const unsigned char* p = (const unsigned char*)text;`で1バイトずつ処理。
    - `if ((*p & 0xc0) == 0x80) continue;`でUTF-8継続バイトをスキップ。
    - ASCII以外はDEL(127)で描画。
    - renderer.cと同じロジックに修正。
    - 英語UIラベルが正しく表示されるようになった。
    - 実装例（修正後のコード）:

```c
void dx11_draw_text(const char* text, int x, int y, mu_Color color) {
    mu_Rect dst = { x, y, 0, 0 };
    mu_Rect src;
    const unsigned char* p;
    for (p = (const unsigned char*)text; *p; p++) {
        if ((*p & 0xc0) == 0x80) continue; // UTF-8継続バイトはスキップ
        int chr = mu_min(*p, 127);         // 範囲外はDEL(127)に丸める
        src = atlas[ATLAS_FONT + chr];
        dst.w = src.w;
        dst.h = src.h;
        dx11_push_quad_atlas(dst, src, color);
        dst.x += dst.w;
    }
}
```

## まとめ
- DirectX11版で英語UIが文字化けした原因は、renderer.cのロジックを正確に移植しなかったこと。
- UTF-8デコードや日本語対応は不要。atlas.inlの1バイトASCIIのみで十分。
- renderer.cのforループをそのままdx11_draw_textに移植することで、英語UIは完全に正しく表示される。
- 何度も誤った修正を繰り返したのは「UTF-8デコードが必要」「日本語対応が必要」と誤認したため。
- 根本原因は「renderer.cのロジックを隅々まで調査しなかったこと」。

---

## DirectX9版(renderer.c)とDirectX11版(dx11_renderer.c)の主な違い

### 1. API・リソース管理
- DirectX9: LPDIRECT3DDEVICE9, IDirect3DVertexBuffer9, IDirect3DIndexBuffer9, IDirect3DTexture9 など COMオブジェクトを直接管理。
- DirectX11: ID3D11Device, ID3D11DeviceContext, ID3D11Buffer, ID3D11Texture2D, ID3D11ShaderResourceView など、より細分化されたリソース管理。

### 2. 頂点・インデックスバッファの更新
- DirectX9: Lock/Unlockでバッファ更新。
- DirectX11: Map/Unmapでバッファ更新。

### 3. シェーダ
- DirectX9: 固定機能パイプライン（FVF, テクスチャステージ）中心。
- DirectX11: HLSLによる頂点/ピクセルシェーダ必須。入力レイアウト・シェーダコンパイルが必要。

### 4. テクスチャ管理
- DirectX9: atlas_texture_d3d (IDirect3DTexture9) を直接SetTexture。
- DirectX11: g_atlasTexture (ID3D11Texture2D) + g_atlasSRV (ID3D11ShaderResourceView) をPSSetShaderResourcesでバインド。

### 5. クリッピング（シザー矩形）
- DirectX9: SetScissorRect, D3DRS_SCISSORTESTENABLE。
- DirectX11: RSSetScissorRects, RasterizerStateでScissorEnable。

### 6. 座標変換
- DirectX9: プロジェクション行列で2D座標変換。
- DirectX11: 頂点シェーダで-1.0〜1.0の正規化座標に変換。

### 7. テキスト描画ロジック
- 両者ともatlas.inlの1バイトASCIIグリフのみ利用。
- DirectX9: UTF-8継続バイトはスキップ、ASCII以外はDEL(127)で描画。
- DirectX11: 最終修正で同じロジックに統一。

### 8. コマンドバッファ
- DirectX9: mu_Commandを直接処理。
- DirectX11: 独自のSimpleCommandバッファで一度コマンドを蓄積し、まとめて描画。

### 9. 初期化・クリーンアップ
- DirectX9: D3DCreate, CreateDevice, Release。
- DirectX11: D3D11CreateDeviceAndSwapChain, CreateRenderTargetView, Release。

## DirectX9/DirectX11の主な違いのソース比較

### 1. 頂点・インデックスバッファの更新

**DirectX9 (renderer.c):**
```c
static int update_vertex_buffer(void)
{
    void* ptr;
    HRESULT hr;
    if (!g_vertex_buffer) return FALSE;
    hr = g_vertex_buffer->lpVtbl->Lock(g_vertex_buffer, 0, vertex_count * sizeof(struct Vertex), &ptr, 0);
    if (FAILED(hr)) return FALSE;
    memcpy(ptr, vertices, vertex_count * sizeof(struct Vertex));
    g_vertex_buffer->lpVtbl->Unlock(g_vertex_buffer);
    return TRUE;
}
```

**DirectX11 (dx11_renderer.c):**
```c
void dx11_flush_vertices(void) {
    if (vertex_count == 0) return;
    D3D11_MAPPED_SUBRESOURCE resource;
    HRESULT hr = g_context->lpVtbl->Map(g_context, (ID3D11Resource*)g_vertexBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &resource);
    if (SUCCEEDED(hr)) {
        memcpy(resource.pData, vertices, vertex_count * sizeof(DX11Vertex));
        g_context->lpVtbl->Unmap(g_context, (ID3D11Resource*)g_vertexBuffer, 0);
    }
    // ...（インデックスバッファも同様）
}
```

---
### 2. シェーダ

**DirectX9 (renderer.c): 固定機能パイプライン**
```c
// 頂点フォーマット指定
D3DFVF_XYZ | D3DFVF_TEX1 | D3DFVF_DIFFUSE
// テクスチャステージ
// ...SetTextureStageState, SetFVF, DrawIndexedPrimitive...
```

**DirectX11 (dx11_renderer.c): HLSLシェーダ**
```c
const char* vertex_shader_code = "...HLSLコード...";
const char* pixel_shader_code = "...HLSLコード...";
// CompileShaderFromString, CreateVertexShader, CreatePixelShader, CreateInputLayout
```

---
### 3. テクスチャ管理

**DirectX9:**
```c
IDirect3DTexture9* atlas_texture_d3d;
d3d_device->lpVtbl->SetTexture(d3d_device, 0, (IDirect3DBaseTexture9*)atlas_texture_d3d);
```

**DirectX11:**
```c
ID3D11Texture2D* g_atlasTexture;
ID3D11ShaderResourceView* g_atlasSRV;
g_context->lpVtbl->PSSetShaderResources(g_context, 0, 1, &g_atlasSRV);
```

---
### 4. クリッピング（シザー矩形）

**DirectX9:**
```c
RECT scissor_rect = { rect.x, rect.y, rect.x + rect.w, rect.y + rect.h };
d3d_device->lpVtbl->SetRenderState(d3d_device, D3DRS_SCISSORTESTENABLE, TRUE);
d3d_device->lpVtbl->SetScissorRect(d3d_device, &scissor_rect);
```

**DirectX11:**
```c
D3D11_RECT scissorRect;
scissorRect.left = rect.x;
scissorRect.top = rect.y;
scissorRect.right = rect.x + rect.w;
scissorRect.bottom = rect.y + rect.h;
g_context->lpVtbl->RSSetScissorRects(g_context, 1, &scissorRect);
```

---
### 5. 座標変換

**DirectX9:**
```c
D3DMATRIX proj;
proj._11 = 2.0f / width;
proj._22 = -2.0f / height;
proj._41 = -1.0f;
proj._42 = 1.0f;
proj._44 = 1.0f;
d3d_device->lpVtbl->SetTransform(d3d_device, D3DTS_PROJECTION, &proj);
```

**DirectX11:**
```c
// 頂点シェーダで-1.0〜1.0の正規化座標に変換
float x0 = 2.0f * dst.x / window_width - 1.0f;
float y0 = 1.0f - 2.0f * dst.y / window_height;
// ...
```

---
### 6. テキスト描画ロジック

**DirectX9:**
```c
for (p = (char*)text; *p; p++) {
    if ((*p & 0xc0) == 0x80) { continue; }
    chr = mu_min((unsigned char)*p, 127);
    src = atlas[ATLAS_FONT + chr];
    dst.w = src.w;
    dst.h = src.h;
    push_quad(dst, src, color);
    dst.x += dst.w;
}
```

**DirectX11:**
```c
for (p = (const unsigned char*)text; *p; p++) {
    if ((*p & 0xc0) == 0x80) continue;
    int chr = mu_min(*p, 127);
    src = atlas[ATLAS_FONT + chr];
    dst.w = src.w;
    dst.h = src.h;
    dx11_push_quad_atlas(dst, src, color);
    dst.x += dst.w;
}
```

---

---
### 追加履歴（2024年6月）

- **GUID/atlas依存の整理**  
  dx11_guid.h, dx11_atlas.h, dx11_atlas.inlの依存を排除。atlas.inlのみをインクルードし、必要な定数は直接定義。IID_ID3D11Texture2Dはinitguid.hとDEFINE_GUIDで明示的に定義。ビルド成功。

- **コードコメントの充実**  
  dx11_renderer.cの関数・グローバル変数・重要な変数に詳細な役割コメントを追加。各リソースやバッファの用途、関数の目的・引数・戻り値などが明確に記載。
