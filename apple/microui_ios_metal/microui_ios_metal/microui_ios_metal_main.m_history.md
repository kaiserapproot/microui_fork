
 MicroUI iOS Metal実装 - 修正履歴
 -------------------------------------------------------------
 2025-06-22: ウィンドウドラッグ問題の修正

 [問題]
 - Log Windowのタイトルバーをドラッグすると、Demo Windowも一緒に移動する問題

 [原因]
 1. ウィンドウ移動処理が重複して実装されていた:
    - touchesMoved: メソッドで各ウィンドウ名を使って正しく移動
    - updateDisplay: メソッドでは「Demo Window」名をハードコードして移動
 2. macOSのマウスイベントとiOSのタッチイベントの違いによる状態管理の問題

 [修正]
 1. updateDisplay: メソッドからウィンドウ移動処理を削除し、touchesMoved: のみで行うように変更
 2. setupWindowDrag: メソッドでドラッグ開始時の状態を明確に保存
 3. フォーカスとホバーの状態管理を改善

 [iOS/macOS対応の主な違いと実装の詳細]

 1. ホバー状態の処理
    - macOS: マウスカーソルがUI要素上に位置するだけでホバー状態が発生
    - iOS: カーソルの概念がないため、タッチ中のみホバー状態を擬似的に作成
    - 実装: ios_fix_hover_state()関数(107-146行目)でホバー状態を管理
           タッチ中はフォーカス要素とホバー要素を同期し、タッチ終了時はホバーをクリア
           例: ctx->hover = ctx->focus; // フォーカスとホバーの同期

 2. イベント処理の差異
    - macOS: mouseDown/mouseMove/mouseUpなどの細かいイベント体系
    - iOS: touchesBegan/Moved/Endedの3状態のみ
    - 実装: touchesBegan(1663-1789行目)でマウスイベントをエミュレート
           例: mu_input_mousedown(ctx, x, y, MU_MOUSE_LEFT); // タッチをマウスクリックに変

 3. UI要素位置の管理
    - macOS: マウスの高精度な位置情報で直接UI要素を特定可能
    - iOS: 指の太さによる不正確さを補うためのヒットテスト拡張が必要
    - 実装: HeaderCache構造体(216-221行目)とios_cache_header()関数(254-264行目)
           UI描画時に位置情報をキャッシュし、タッチ時に素早く要素を特定

 4. ウィンドウドラッグ処理
    - macOS: マウス位置の連続的な変化で自然にドラッグ
    - iOS: タッチ開始位置と現在位置の差分計算が必要
    - 実装: setupWindowDrag()メソッド(1642-1676行目)とtouchesMoved()メソッド(1805-1842行)
           例: CGFloat dx_f = location.x - self.dragStartTouchPosition.x; // 差分計算

 5. 状態の永続管理
    - macOS: ホバー状態などが自然に維持される
    - iOS: 明示的な状態保持と復元が必要
    - 実装: PersistentHeaderState構造体(144-148行目)と関連関数
           ios_set_header_state()、ios_get_header_state()などで永続的状態を管理

 [iOSの独自処理]

 1. タッチイベントのキュー管理
    - 実装: queueEvent()メソッド(1488-1496行目)
    - 内容: タッチイベントをNSMutableArrayにキューイングし非同期処理を可能に
           背景処理中にタッチイベントが失われないよう保持

 2. DisplayLink管理
    - 実装: setupDisplayLink()メソッド(1256-1266行目)とupdateDisplay()メソッド(1335-1483行)
    - 内容: 60FPSの安定したレンダリングを実現するためのCADisplayLink制御
           メインスレッドでの描画同期とパフォーマンス最適化

 3. タッチ座標補正
    - 実装: getTouchLocation()メソッド(1558-1565行目)
    - 内容: デバイスの解像度とUI座標系の違いを補正し、MicroUIの座標系に正確にマッピング

 [Metal処理の内容]

 1. レンダラー初期化
    - 実装: MetalRenderer initWithMetalKitView()メソッド(663-689行目)
    - 内容: Metal用のデバイス、コマンドキュー、レンダリングパイプラインの初期化
           固有のシェーダーとバッファ準備

 2. アトラステクスチャ管理
    - 実装: createAtlasTexture()メソッド(757-790行目)
    - 内容: MicroUIのUI要素をレンダリングするためのアトラステクスチャをMetalで処理
           8bitグレースケールテクスチャを生成・管理

 3. バッファ管理
    - 実装: renderFrame()メソッド(891-923行目)
    - 内容: 頂点、インデックス、ユニフォームバッファの効率的管理
           MicroUIのレンダリングコマンドをMetalのドローコールに変換

 [MicroUIの処理とiOSへの適応]

 1. コマンド処理パイプライン
    - 原理: MicroUIはレンダリングコマンドを生成、実行環境がそれを解釈して描画
    - 適応: mu_begin/mu_end()の間で生成されたコマンドをiosDrawCommandList()で処理(1097-1149目)
           例: mu_Command* cmd = NULL; while (mu_next_command(ctx, &cmd)) { ... }

 2. ウィジェットレイアウト適応
    - 原理: MicroUIは座標と幅/高さで要素を配置
    - 適応: iOS画面サイズに合わせた自動スケーリング(1550-1565行目)
           タッチ領域の拡大でファットフィンガー問題に対応

 3. イベント伝播モデルの変換
    - 原理: MicroUIのイベント処理はマウス中心設計
    - 適応: タッチイベントをmu_input_mousedown/move/up()に変換(1663-1852行目)
           マルチタッチからシングルタッチへの簡略化

 4. 描画処理の最適化
    - 原理: MicroUIは描画コマンドを抽象化している
    - 適応: Metalへ効率的に変換するための中間レイヤー(891-989行目)
           バッチ処理によるドローコール最適化
           ios_set_header_state()、ios_get_header_state()などで永続的状態を管理

 [描画処理（Rendering Process）の詳細]

 1. レンダリングパイプラインの全体フロー
    - CADisplayLinkによる60FPSタイミング制御（setupDisplayLink: 1256-1266行目）
    - updateDisplay:メソッドがフレーム描画のメイン入口点（1451-1483行目）
    - mu_begin/mu_end間でMicroUIの論理フレームを構築
    - 描画コマンドをMetalコマンドバッファに変換して実行

 2. 描画更新とジオメトリ構築（updateDisplay:メソッド内）
    - ステップ1: mu_begin(ctx)でMicroUIコンテキスト更新開始（1462行目）
    - ステップ2: ヘッダーキャッシュをクリア（1465行目）
    - ステップ3: キューに溜まったイベントの処理（1468-1486行目）
    - ステップ4: ウィンドウとウィジェットの配置・レイアウト（processFrameメソッド内、097-1167行目）
    - ステップ5: mu_end(ctx)でMicroUIコマンド生成完了（1600行目）
    - ステップ6: iosDrawCommandList関数でコマンド解釈・変換（1097-1149行目）
    - ステップ7: drawablePrepareToRenderFrameで描画準備（1604行目）
    - ステップ8: MEtalView.draw実行（1609行目）

 3. Metal描画パイプライン（renderFrameメソッド: 1072-1096行目）
    - ステップ1: コマンドバッファとレンダーコマンドエンコーダー生成（891-923行目）
    - ステップ2: 頂点バッファ、インデックスバッファ更新（924-950行目）
    - ステップ3: テクスチャとサンプラー設定（952-970行目）
    - ステップ4: ドローコール実行：drawIndexedPrimitives（972-980行目）
    - ステップ5: コマンドバッファをコミットして描画実行（982-988行目）

 4. 描画最適化技術
    - インスタンシング: 同一テクスチャの要素をバッチ処理（renderFrameメソッド内）
    - アトラステクスチャ: 複数UIパーツを1枚のテクスチャに集約（757-790行目）
    - ジオメトリバッチング: 同一マテリアルの要素をグループ化（950-970行目）
    - ダブルバッファリング: MetalViewのdrawableTexture切替えで描画とディスプレイ転送を分離

 [タップイベント処理の詳細]

 1. タップイベント処理のフロー全体
    - iOS UIKitイベント → MicroUI内部イベントへの変換
    - タッチ座標の正規化処理とMicroUI座標系へのマッピング
    - キュー管理による非同期イベント処理
    - 階層化されたヒットテスト処理によるUI要素特定

 2. タップ開始処理（touchesBegan:メソッド: 1790-1852行目）
    - ステップ1: タッチ座標取得とバリデーション（1791-1809行目）
      - getTouchLocation:メソッドで座標を取得（1558-1565行目）
      - 座標が有効範囲外なら処理を終了
    - ステップ2: タッチ対象の特定（1811-1818行目）
      - windowNameAtTitleBarPoint:メソッドでヒットしたウィンドウ判定（以前実装を追加）
      - ios_detect_header_at_pointメソッドで特殊ヘッダー要素の判定
    - ステップ3: ウィンドウドラッグ開始処理（1820-1835行目）
      - ウィンドウタイトルバータッチならドラッグモード開始
      - setupWindowDrag:メソッドでドラッグ状態を初期化（1642-1676行目）
      - ドラッグ開始位置と対象ウィンドウ情報を保存
    - ステップ4: ヘッダー操作処理（1836-1850行目）
      - ヘッダータッチならヘッダー固有の状態を設定
      - ios_get_header_at_position関数でヘッダーIDと状態を取得
      - mu_set_focusとios_set_hoverで状態更新
    - ステップ5: イベントキューイング（1866-1886行目）
      - queueEvent:メソッドでタッチ状態をイベントキューに追加（1488-1496行目）
      - 非同期のUpdateDisplay処理で後ほど反映
